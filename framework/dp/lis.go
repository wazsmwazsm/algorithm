package dp

/*
  给定一个无需的整数数组，找到其中最长上升子序列的长度

  int longestIncreasingSubsequence([]int a);

  例如 给定数组 [10,9,2,5,3,7,101,18] 最长上升子序列为 [2,3,7,101] , 长度为 4
*/

/*

	思路，子序问题，使用动态规划

	直接定义 dp[i] 为长度为 i 时最长子序，不太好写，那么转换思路，换求以 i 为结尾的最长子序长度
	这样将数组的每个值当结尾的最长子序长度获取后，取最大即可

	DP 定义: dp[i] 表示以 nums[i] 这个数结尾的最长递增子序列的长度
	根据定义，最长子序列则为 dp 数组中最大的那个

	只要将 nums[i] 为结尾的最长递增子序列求出来，对比大小即可

	状态转移方程
		f(n) = 1, n=1;
		f(n) = f(2~n-1)+1, n>1 && nums(n) > nums(n-1);

	这个解法其实相当于求了多次 dp，最后在多个 dp 结果里挑选 时间 O(n^2) 空间 O(n)

*/

func longestIncreasingSubsequence(a []int) int {
	la := len(a)
	dp := make([]int, la)
	for i := 0; i < la; i++ {
		dp[i] = 1 // base case
	}

	for i := 0; i < la; i++ {
		for j := 0; j < i; j++ { // 每一个子数组作为一个以 nums[i] 为结尾的 dp 问题求解
			if a[i] > a[j] {

				if dp[i] < dp[j]+1 { // 遇到更大的数，最长子序加一
					dp[i] = dp[j] + 1
				}

			}
		}
	}

	// 多个问题求完，选最大
	max := 0
	for i := 0; i < la; i++ {
		if max < dp[i] {
			max = dp[i]
		}
	}

	return max
}

// /*
// 	思路二：

// 	转换为求各个以 nums[i] 为结尾的子序，主要在于不好获取子串中最大的那个数
// 	那么这个思路就记录这个数，如何求子序中最大数作为重点，下面举出一些例子

// 	以 [10,9,2,5,3,7,101,18,20] 为例

// 		10 时，最大数就是 10，最长子序 1
// 		9 时，最大数就是 9，最长子序 1
// 		2 时，最大数就是 2，最长子序 1
// 		5 时，最大数就是 5，最长子序 2 （2，5）
// 		3 时，最大数就是 3，最长子序 2 （2，3）
// 		7 时，最大数就是 7，最长子序 3 （2，5，7  2，3，7）
// 		101 时，最大数就是 101，最长子序 4 （2，5，7，101  2，3，7，101）
// 		18 时，最大数就是 18，最长子序 4 （2，5，7，18  2，3，7，18）
// 		20 时，最大数就是 20，最长子序 5 （2，5，7，18，20  2，3，7，18，20 ）

// 	以 [10, 2, 4, 6, 7, 8, 1, 5, 3] 为例
// 		10 时，最大数就是 10，最长子序 1
// 		2 时，最大数就是 2，最长子序 1
// 		4 时，最大数就是 4，最长子序 2 （2，4）
// 		6 时，最大数就是 6，最长子序 3 （2，4，6）
// 		7 时，最大数就是 7，最长子序 4 （2，4，6，7）
// 		8 时，最大数就是 8，最长子序 5 （2，4，6，7，8）
// 		1 时，最大数就是 8，最长子序 5 （2，4，6，7，8）
// 		5 时，最大数就是 8，最长子序 5 （2，4，6，7，8）
// 		3 时，最大数就是 8，最长子序 5 （2，4，6，7，8）

// 	那么 ok，我们可以观察到什么时候子序最大数变化，即最长子序为 1 时，最大数一直移动
// 	之后只有最大数大于当前数时才移动最大数

// 	dp[i] 定义为 长度为 i 的数组的最长子序

// 	状态转移方程
// 		f(n) = 1, n=1;
// 		f(n) = f(n-1)+1, n>1 && nums[n] > maxNum(n-1);

// */
// // [10,9,2,5,3,7,101,18,20]

// func findLISMaxNum(a []int) int {
// 	la := len(a)

// 	maxNum := a[0]
// 	lis := 1
// 	for i := 1; i < la; i++ {
// 		if a[i] > a[i]-1 {

// 		}
// 	}
// }

// func longestIncreasingSubsequence2(a []int) int {
// 	la := len(a)
// 	dp := make([]int, la)
// 	dp[0] = 1 // base case

// 	maxSubNum := a[0] // 子序里最大的字符

// 	for i := 1; i < la; i++ {
// 		if a[i] > maxSubNum {
// 			dp[i] = dp[i-1] + 1
// 			maxSubNum = a[i]
// 		} else {
// 			if i > 2 && dp[i-1] == dp[i-2] {
// 				maxSubNum = a[i]
// 			}
// 			dp[i] = dp[i-1]

// 		}
// 	}
// 	fmt.Println(dp)
// 	return dp[la-1]
// }
